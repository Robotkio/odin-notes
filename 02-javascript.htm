<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Course - Odin Notes</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/notes-style.css">
    <script src="js/foldable-sections.js" defer></script>
</head>

<body>
    <div id="foldables">
        <h1>JavaScript Course</h1>
        <p><strong>Introduction</strong> just covers course structure and review.</p>
        <section>
            <h2>Introduction</h2>
            <p>Everything in here is contextual and review. Nothing to dig into.</p>
            <section>
                <h3>How This Course Will Work</h3>
                <ul>
                    <li>Really just an overview of how the course will be structured. It's like the rest of them.</li>
                </ul>
            </section>
            <section>
                <h3>A Quick Review</h3>
                <ul>
                    <li>Just about the only thing this part mentions is that jQuery has kind of fallen out of use because of DOM manipulation and AJAX are a lot easier now.</li>
                </ul>
            </section>
        </section>
        <section>
            <h2>Organizing Your JavaScript Code</h2>
            <p>Organizing your JavaScript Code is just a section overview.</p>
            <section>
                <h3>Organizing your JavaScript Code Introduction</h3>
                <ul>
                    <li>Going to cover some patterns: JavaScript Objects, Object Constructors, Factory Functions, Module Pattern, Classes and ES6 Modules.</li>
                    <li>It's also going to cover concepts like "closure", "prototypes" and whatever "IIFEs" are.</li>
                </ul>
            </section>
            <section>
                <h3>Objects and Object Constructors</h3>
                <ul>
                    <li>Review of object syntax: <br>
                    <code class="block">const myObject = { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;property: 'Value!', <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;otherProperty: 77, <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;"obnoxious property": function() { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do stuff! <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                    };</code></li>
                    <li>Accessing information review: <br>
                    <code class="block">myObject.property; // 'Value'<br>
                    myObject["obnoxious property"]; // [Function]</code></li>
                    <li>Useful little reminder, you can acces properties within objects with variables like so: <br>
                    <code class="block">const variable = 'otherProperty'; <br>
                    myObject.variable; // doesn't work <br>
                    myObject[variable]; // looks for a property called 'otherProperty' and returns 77</code></li>
                    <li>Define an object like this: <br>
                    <code class="block">function Player(name, marker) { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;this.name = name; <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;this.marker = marker; <br>
                    }</code></li>
                    <li>And instantiate it like this: <br>
                        <code>const player = new Player('Steve', 'X');</code>
                    </li>
                    <li>You can add functions pretty much like any other language except you seem to have to write them like this, for instance in the previous Player object: <br>
                    <code class="block">this.sayName = function() { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);
                    }</code></li>
                    <li>Weirdly, you can call constructors without using the new keyword which does some bad stuff. So you can safeguard your constructor: <br>
                    <code class="block">if(!new.target) { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;throw Error("Use 'new' operator!"); <br>
                    }</code></li>
                    <li>Course asks me to make a constructor for a book, I'm pretty confident.</li>
                    <li>Every object has a "prototype" which I think is the generic object blueprint that all instances of that object inherit from.</li>
                    <li>You can access an objects prototype through, for instance, <code>layer.prototype;</code> or <code>Object.getPrototypeOf(playerVariable);</code></li>
                    <li>You could see playerVariable.__proto__ or playerVariable.[[Prototype]] but these are deprecated.</li>
                    <li>Object prototypes inherit from a base Object prototype with some built-in functions available to all Objects.</li>
                    <li>Some built-in functions include <code>.valueOf()</code> which will get the value of an object, output varries by browser. Also <code>.hasOwnProperty('propertyName')</code> to check for the existance of a property.</li>
                    <li>JS is single-inheritance.</li>
                    <li>You use a line of code outside the object declaration to make an object inherit. It's with <code>Object.setPrototypeOf(AdvancedPlayer.prototype, Player.prototype)</code>. In this case AdvancedPlayer inherits from Player.</li>
                    <li>It's useful to check for prototype matches, too, with something like: <code>Array.prototype.isPrototypeOf(objectVariable);</code> in this case it checks if the "objectVariable" object is of type array.</li>
                    <li><mark>You need to set up this inheritance before instantiating any of the objects!</mark></li>
                    <li>You "can" do something like <code>AdvancedPlayer.prototype = Player.prototype;</code> but that overwrites its prototype, not adds it.</li>
                    <li>Note, a constructor function is just any old function. It's customary to capitalize its first letter and it's required to use the "new" keyword to instantiate it.</li>
                    <li>Thankfully it is common practice to define functions inside an object, not assign it later, for readability purposes.</li>
                    <li>I believe there's also function overloading. If a parent has a function and you assign a new function to a child objects function property it will be overwritten.</li>
                    <li>The inheriting object is used for variable storage. That's where the keyword <code>this</code> comes into play. It always references the object. There's a good <a href="https://javascript.info/prototype-inheritance#the-value-of-this">example here</a>. So if a function that's defined in the parent adds a property value to a child that value is stored in the child.</li>
                    <li><code>for..in</code> loops will go through all properties of an object. So <code>for(let prop in player) alert(prop);</code> would list all the properties in a Player object.</li>
                    <li>One article mentions "this" works just like it does in Java, C# or PHP. I don't feel the need to read further.</li>
                </ul>
            </section>
            <section>
                <h3>Factory Functions and the Module Pattern</h3>
                <ul>
                    <li><code>var</code> is "function scoped" which I think means it's open to anything within the function it's declared in, even if it's declared in a deeper scope</li>
                    <li><code>let, const</code> are block scoped, like a normal variable</li>
                    <li>This seems useful to remember: <br>
                    <code class="block">
                        function madeAdding(firstNumber) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const first = firstNumber; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return function resulting(secondNumber) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const second = secondNumber; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return first + second; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        } <br>
                        const add5 = makeAdding(5); <br>
                        console.log(add5(2)); // 7 is logged
                    </code>
                    The function returns a function so add5 is now the function that madeAdding() returned. Scope-wise, it also holds the value 5 somehow.</li>
                    <li>That '5' being maintained is called "lexical environment". When the function was declared it remembers the surrounding state.</li>
                    <li>Ahh, JS works a bit different. Blocks in JS don't create scopes. "let" and "const" functionally add block scope by being block scope.</li>
                        <li>An example use-case for this: <br>
                        <code class="block">
                            function makeSizer(size) { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return function () { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   document.body.style.fontSize = `${size}px`; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;}; <br>
                            } <br>
                            const size12 = makeSizer(12); <br>
                            const size16 = makeSizer(16); <br>
                            document.getElementById("size-12").onclick = size12; <br>
                            document.getElementById("size-16").onclick = size16;
                        </code>
                        This creates a "function factory". In this case it produces functions that change the pages font size that can be added to onclick events.</li>
                    <li>Apparently constructors, like classic, object-oriented class <mark>constructors, aren't great</mark>. They look like regular functions. <code>instanceof</code> ins't great in JS because the constructor could have been changed since the object was instantiated and this wouldn't reflect that.</li>
                    <li>Factory functions, like the above example, is more consistent but does have a performance hit.</li>
                    <li>Here's an example of a constructor refactored into a factory function: <br>
                    <code class="block">const User = function(name) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.discordName = '@' + name;<br>
                        }<br>
                        // refactor ...<br>
                        function createUser(name) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const discordName = '@' + name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return { name, discordName };<br>
                        }
                    </code></li>
                    <li>Little aside: the above <code>{ name, discordName }</code> creates an object dynamically, kind of like <code>{ name: name, discordName: discordName }</code>, it's just that the internal variables of the object are named after the variables used to create it.</li>
                    <li>It lets you do neat things like <code>console.log({ name, age, color });</code> and it will output in a much more readable way that will list the variable name alongside their values.</li>
                    <li>Weirdly, you can deconstruct objects like this: <br>
                    <code class="block">
                        const obj = { a: 1, b: 2 }; <br>
                        const { a, b } = obj; <br>
                        <br>
                        const array = [1,2,3,4]; <br>
                        const [ zerothElement, firstElement ] = array;
                    </code>The first two lines create two variables, "a" and "b" that are the values of obj.a and obj.b respectively. The second two lines create two variables that are the first two elements of the array.</li>
                    <li>WTF, there's even weirder things in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring">this MDN article</a>.</li>
                    <li>The factory method lets us make private variables by taking advantage of that lexical environment. Having a variable in the factory counts as part of the context of the object creation but isn't an attribute accessable through, say, the dot operator. <br>
                        <code class="block">
                            function createUser(name) { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;let reputation = 0; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const getReputation = () => reputation; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const giveReputation = () => reputation++; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return { name, getReputation, giveReputation }; <br>
                            } <br>
                            const josh = createUser("josh"); <br>
                            josh.giveReputation(); <br>
                            console.log( { name: josh.name, reputation: josh.getReputation() } );
                        </code>
                    This basically creates a user object with methods but doesn't give access to the reputation variable since that's part of the lexical environment.</li>
                    <li>You can do this in a constructor, but <mark>inheritance doesn't have access to the context of the constructor</mark> so it's not a good combo.</li>
                    <li>We can extend factories like inheritance: <br>
                        <code class="block">
                        function createPlayer(name, level) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const { getReputation, giveReputation } = createUser(name); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const increaseLevel = () => level++; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return { name, getReputation, giveReputation, increaseLevel }; <br>
                        }
                        </code>Apparently that's it. That can pull the old functions out, create new ones and return a new object with what was previously a User at its core.</li>
                    <li>There's an alternative to the return line: <br>
                        <code>return Object.assign({}, user, { increaseLevel });</code></li>
                        I'm not entirely sure how it works but I can look into it.
                    <li>There's another couple of useful things: the "module pattern" and IIFE's</li>
                    <li>IIFE stands for Immediately Invoked Function Expression and involves wrapping a function in brackets and then immediately calling it. This helps to encapsulate the variables and functions within. See this example:
                        <code class="block">
                            const calculator = (function () { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const add = (a, b) => a + b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const sub = (a, b) => a - b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const mul = (a, b) => a * b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const div = (a, b) => a / b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return { add, sub, mul, div }; <br>
                            })(); <br>
                            calculator.add(3,5); // 8 <br>
                            calculator.sub(6,2); // 4 <br>
                            calculator.mul(14,5534); // 77476 <br>
                        </code>
                        The generic function is wrapped in () and then there's a () right after it that invokes it.
                    </li>
                    <li>This method also helps encapsulate these functions by making it necessary to put <code>calculator.</code> in front of them to invoke them. This helps avoid global level functions from having naming conflicts.</li>
                    <li><mark>Avoid global variables!</mark></li>
                    <li>Heck, encapsulate your whole module in a self-acting function that returns to your module name.</li>
                </ul>
            </section>
            <section>
                <h3>Classes</h3>
                <ul>
                    <li>Interestingly, JS added classes but it's really only in name and syntax. They aren't like classes in other OO languages, it's just syntactic sugar for what I've already been doing.</li>
                    <li>So, for the syntactic sugar I can use <code>get, set</code> instead of <code>function</code> to basically do the same thing.</li>
                    <li>The neat thing: this makes it so that you can just use the dot operator and the get/set methods will be used automatically.</li>
                    <li>So if there's an object:
                        <code class="block">let user = { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;name: "John", <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;surname: "Smith",
                            &nbsp;&nbsp;&nbsp;&nbsp;get fullName() { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `${this.name} ${this.surname}`; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;}, <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;set fullName(value) { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[this.name, this.surname] = value.split(" ");<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                            }; <br></code>
                        Then you can call it with <code>user.fullName</code> or assign to it like <code>user.fullName = "Alice Cooper";</code>
                    </li>
                    <li>Class syntax is like this: <br>
                        <code class="block">class User { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;constructor(name) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;sayHi() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.name); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        } <br>
                        let user = new User("John"); <br>
                        user.sayHi();
                        </code></li>
                    <li>When the keyword <code>new</code> is used it implicitly, inside the constructor, creates an object called "this" before running all the other constructor instructions and then returns "this" at the end of it.</li>
                    <li><mark>You don't need to put a comma between class methods</mark>, unlike in object literals!</li>
                    <li><code>User</code> in the above code is still a function with the function code taken from the constructor. Class methods are stored in User.prototype.</li>
                    <li>We could (mostly) get the same function as creating a class doing it this way:
                        <code class="block">function User(name) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.name = name; <br>
                        } <br>
                        User.prototype.sayHi = function() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;alert(this.name); <br>
                        };</code>
                        Though <a href="https://javascript.info/class">this document</a> says (unlike TOP) that <mark>it's not just syntactic sugar!</mark>
                    </li>
                    <li>A function created by a class is labelled by a special, interal property <code>[[IsClassConstructor]]: true</code> that is checked for in a number of places.</li>
                    <li>It forces the usage of <code>new</code></li>
                    <li>Class methods are non-enumerable. This means if you for..in them you wont iterate over the class methods.</li>
                    <li>All code inside a class is in strict mode. (Makes it function a little closer to compiled languages I'm used to.)</li>
                    <li>Computed function names are weird.
                        <code class="block">class User { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;['say' + 'Hi']() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert("Hello"); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        }</code>
                    </li>
                    <li>Class fields seem just like fields. I can't really remember why this is unique in some way. They're just <br>
                    <code>name = "John";</code> and accesed through <code>user.name;</code>. </li>
                    <li>There's apparently an interesting issue called "losing this". Take this code: <br>
                    <code class="block">class Button { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;constructor(value) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;click() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.value); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        } <br>
                        let button = new Button("hello"); <br>
                        <mark>setTimeout(button.click, 1000); // undefined</mark></code></li>
                        The issue is the "click" function "losing this". You need to change it to:
                        <code class="block">click = () => { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;alert(this.value); <br>
                        }</code>
                        I think this is related to the lexical environment concept.
                    <li>It's also apparently common parlance put an underscore in front of a public variable that you shouldn't mess with.</li>
                    <li>Interesting tip: if you have a depricated value in an object, say "age", and you replaced it with "birthday". You could create an age getter that calculates the age from birthday and returns that so the rest of the code doesn't have to be updated.</li>
                    <li>The next notes are from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">a few MDN articles</a>. TOP suggested not memorizing everything so these notes will be more sparse, probably ...</li>
                    <li>If you declare an object, it seems like it should have a function named <code>constructor</code></li>
                    <li>I don't know what a "static initialization block" is. Probably good to read more at some point.</li>
                    <li>You can actually declare methods or fields static. Use it instead of "let" or "function".</li>
                    <li>You seem to be able to define fields as private like <code>#height = 0;</code> (by adding the #). I think it makes referencing them an error?</li>
                    <li>You can do good ol <code>class Dog extends Animal { }</code></li>
                    <li><mark>If the child class has a constructor it needs to call <code>super()</code> in it!</mark></li>
                    <li>The right side of "extends" doesn't have to be an identifier. It just has to evaluate to a constructor.</li>
                </ul>
            </section>
            <section>
                <h3>ES6 Modules</h3>
                <ul>
                    <li>ES6 & ESM can get rid of global scoped variables without having to put them in an IIFE.</li>
                    <li>There are two ways to export things out of an ESM file, both use <code>export</code>
                    <code class="block">// consider this in a file one.js <br>
                        export const greeting = "Hello world!"; <br>
                        // or ... <br>
                        const greeting = "Hello world!"; <br>
                        // then, near the end of the file ... <br>
                        export { greeting };</code></li>
                        Both will export, but that doesn't automatically make it global.
                    <li>To import an exported value into another file you ...
                        <code class="block">import { greeting } from "./one.js"; <br>
                        console.log(greeting);</code>
                    </li>
                    <li>Note: the syntax of using { } to import and export <mark>doesn't create an object</mark>.</li>
                    <li>There's another keyword, <code>default</code> that's also used for exporting. <mark>A file can only default export a single thing!</mark>
                        <code class="block"> // consider this in file one.js <br>
                        export default "Hello world!"; <br>
                        // or ... <br>
                        const greeting = "Hello world!"; <br>
                        export default greeting;</code>
                        Then, in another file you can import it. There's no actual variable name associated with exporting a default value so it can be renamed in the new file.
                        <code class="block">import helloMessage from "./one.js";</code></li>
                    <li>Apparently there isn't really an agreed upon standard for when to use default and when to use export.</li>
                    <li>A little note on syntax for importing both a default and standard exports: <br>
                        <code class="block">// consider this in "one.js" <br>
                        export default "Hello, world!"; <br>
                        export const farewell = "Goodbye, world!" <br></code>
                        Now, in another file ...
                        <code class="block">import greeting, { farewell } from "./one.js";</code></li>
                    <li>This creates file dependencies which we can leave to the browser to import the correct ones. Use the following in the HTML
                        <code>&lt;scrip src="two.js" <mark>type="module"</mark>&gt;&lt;script&gt;</code>. The <code>type="module"</code> lets the browser check out the imports and will also load the associated imports.
                    </li>
                    <li>This means you only need to have the least depended on file linked to the HTML. Or even specifically have one that loads the others.</li>
                    <li>Also, <code>type="module"</code> acts as if you used the keyword <code>defer</code> so you don't need both.</li>
                    <li>Fun fact: <mark>for security reasons modules like this will not be loaded if you open the HTML directly in the browser</mark> so I have to use an VS Code extension called "Live Preview".</li>
                    <li>You can declare that a variable is exported before the variable is declared. (Useful for exports at the top of the file.)</li>
                    <li>You can rename imports and exports with the "as" keyword. For example: <br>
                        <code>export { myLongNameFunction as myFunc };</code> and then <br>
                        <code>import { myFunc as otherModuleFunc } from "module-name";</code></li>
                    <li>You can pass along exports from one file straight on through by <br>
                        <code>export { default as func1, func2 } from "other_module.js";</code></li>
                    <li>You could also just <code>export * from "module";</code> to pass everything through except for the default.</li>
                </ul>
            </section>
            <section>
                <h3>npm</h3>
                <ul>
                    <li>npm (no capitals) apparently doesn't stand for Node Package Manager, though people will call it that. It does manage packages, though it does it just for JavaScript, not just Node.js.</li>
                    <li>npm seems to revolve around a projects "package.json" file. That file has information about a projects dependencies and we would be able to use "nmp install" to install the required packages.</li>
                    <li>installing a package just involves running <code>npm install &lt;package_name&gt;</code></li>
                    <li>It will look for the package.json file to see which version it should install, if no package.json exists then the latest version will be installed.</li>
                    <li>I don't understand what a scope is in this context but you can install scoped packages: <br>
                        <code>npm install @scope/package-name</code></li>
                    <li>You can install private packages the same way if you have read access.</li>
                    <li>To see if it worked: look for a "node_modules" directory placed in the same directory that you ran npm in. Or <code>ls node_modules</code></li>
                    <li>You can install different distributions by <code>npm install example-package@beta</code></li>
                    <li>Adding a package.json file makes it easier for others to install dependencies.</li>
                    <li>A package.json file has some required elements: name, version. Author is optional:
                        <code class="block">{<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;"name": "my-awesome-package",<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;"version": "1.0.0",<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;"author": "Your Name &lt;email@example.com&gt; (https://example.com)"<br>
                        }</code>
                        The formatting is important. Version must be "x.x.x" and author must be "name &lt;email&gt; (website)"
                    </li>
                    <li>You can create a package.json through npm by navigating to the directory and running <code>npm init</code>. It will run through a questionaire.</li>
                    <li>For some reason you can make a custom questionaire? It's mentioned <a href="https://docs.npmjs.com/creating-a-package-json-filehttps://docs.npmjs.com/creating-a-package-json-file">on this site</a>.</li>
                    <li>You can also run <code>npm init --yes</code> to make a package.json with default values extracted from the current directory.</li>
                    <li>For running code, these packages are called "dependencies". If you only use them for developing the program (like testing) then they're called "development dependencies" or devDependencies in the json file.</li>
                </ul>
            </section>
            <section>
                <h3>Webpack</h3>
                <ul>
                    <li>Webpack is a bundler. In that we provide it an entry point, it builds a dependency graph, then it merges all the files into one.</li>
                    <li>It can also "minify" code to remove readability formatting and perform "tree shaking" that seeks out unreferenced code to remove.</li>
                    <li>TOP mentions the difference between "src" and "dist" folders standing for "source" and "distribution". It's industry standard to work in src and then the bundler will package everything into dist.</li>
                    <li>Note, you don't need file extensions in Webpack, but ESM does need it. I think I'm just going to use extensions.</li>
                    <li>TOP goes through a tutorial setting up two .js files in the src/ folder: one called index.js that imports another .js file into it.</li>
                    <li>Then run <code>npm init -y</code> to create the npm dependency file package.json.</li>
                    <li>Then run <code>npm install --save-dev webpack webpack-cli</code> to install Webpack</li>
                    <li>The "--save-dev" tells npm to consider these for development dependencies and not production dependencies.</li>
                    <li>Then, back in the root directory we create a file <code>webpack.config.js</code> that contains the following:
                        <code class="block">const path = require("path");<br>
                            module.exports = {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;mode: "development",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;entry: "./src/index.js",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;output: {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename: "main.js",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path: path.resolve(__dirname, "dist"),<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean: true,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;},<br>
                            };</code>
                        This is, apparently, using CommonJS formatting and not what I've been taught. But it grabs index.js from the src/ folder and builds it, and all its dependencies, into main.js in the dist/ folder.</li>
                    <li>Development mode does ... something and "clean: true" clears out the dist/ folder before building.</li>
                    <li>If that's all good I use <code>npx webpack</code> to build it.</li>
                    <li>There's tutorial steps for HTML, CSS, images and more. To install these you need to run:
                        <code class="block">
                            npm install --save-dev html-webpack-plugin // for HTML<br>
                            npm install --save-dev style-loader css-loader // for CSS<br>
                            npm install --save-dev html-loader // for images
                        </code>
                    </li>
                    <li>I'll cover the webpack.config.js file later. For now I'll cover specific notes about the ongoing process.</li>
                    <li>For CSS: I needed to add <code>import "./styles.css";</code> into index.js.</li>
                    <li>This is done because, in the future, it makes more sense to import many, smaller CSS files into whichever module uses them. The packager will merge them all in the end anyway.</li>
                    <li>There are three ways to do images: (1) through <code>url()</code> in CSS (2) through things like the src of an &lt;img&gt; and (3) images used in JavaScript</li>
                    <li>css-loader already handles it through CSS, html-loader handles images through HTML with some configuration, webpack handles images through JS with some configuration.</li>
                    <li>The final webpack.config.js looks like this:
                        <code class="block">const path = require("path");<br>
                            const HtmlWebpackPlugin = require("html-webpack-plugin");<br>
                            module.exports = {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;mode: "development",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;entry: "./src/index.js",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;output: {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename: "main.js",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path: path.resolve(__dirname, "dist"),<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clean: true,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;},<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;plugins: [<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new HtmlWebpackPlugin({<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template: "./src/template.html",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}),<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;],<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;module: {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rules: [<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test: /\.css$/i,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use: ["style-loader", "css-loader"],<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test: /\.html$/i,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loader: "html-loader",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test: /\.(png|svg|jpg|jpeg|gif)$/i,<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: "asset/resource",<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;},<br>
                            };
                        </code>
                    </li>
                    <li><mark>Note, the two css loaders need to be in that order!</mark></li>
                    <li>Lastly, the tutorial installs <code>npm install --save-dev webpack-dev-server</code> then runs <code>npx webpack serve</code> whenever we save. It also makes sure that error codes point to our source files, not the big, hybrid files that the packager makes.</li>
                    <li>It requires adding some code to the webpack.config.js file. After "output" and before "plugins" add:
                        <code class="block">
                            devtool: "eval-source-map",<br>
                            devServer: {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;watchFiles: [".src/template.html"],<br>
                            },
                        </code>
                    </li>
                    <li>The webpack-dev-server can host the files locally so the page can be viewed on http://localhost:8080/</li>
                    <li>Note, the webpack-dev-server only reads the webpack config when you launch it. You'll have to stop it and run <code>npx webpack serve</code> again</li>
                    <li></li>
                </ul>
            </section>
        </section>
    </div>
</body>

</html>