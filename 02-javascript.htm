<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Course - Odin Notes</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/notes-style.css">
    <script src="js/foldable-sections.js" defer></script>
</head>

<body>
    <div id="foldables">
        <h1>JavaScript Course</h1>
        <p><strong>Introduction</strong> just covers course structure and review.</p>
        <section>
            <h2>Introduction</h2>
            <p>Everything in here is contextual and review. Nothing to dig into.</p>
            <section>
                <h3>How This Course Will Work</h3>
                <ul>
                    <li>Really just an overview of how the course will be structured. It's like the rest of them.</li>
                </ul>
            </section>
            <section>
                <h3>A Quick Review</h3>
                <ul>
                    <li>Just about the only thing this part mentions is that jQuery has kind of fallen out of use because of DOM manipulation and AJAX are a lot easier now.</li>
                </ul>
            </section>
        </section>
        <section>
            <h2>Organizing Your JavaScript Code</h2>
            <p>Organizing your JavaScript Code is just a section overview.</p>
            <section>
                <h3>Organizing your JavaScript Code Introduction</h3>
                <ul>
                    <li>Going to cover some patterns: JavaScript Objects, Object Constructors, Factory Functions, Module Pattern, Classes and ES6 Modules.</li>
                    <li>It's also going to cover concepts like "closure", "prototypes" and whatever "IIFEs" are.</li>
                </ul>
            </section>
            <section>
                <h3>Objects and Object Constructors</h3>
                <ul>
                    <li>Review of object syntax: <br>
                    <code class="block">const myObject = { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;property: 'Value!', <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;otherProperty: 77, <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;"obnoxious property": function() { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do stuff! <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                    };</code></li>
                    <li>Accessing information review: <br>
                    <code class="block">myObject.property; // 'Value'<br>
                    myObject["obnoxious property"]; // [Function]</code></li>
                    <li>Useful little reminder, you can acces properties within objects with variables like so: <br>
                    <code class="block">const variable = 'otherProperty'; <br>
                    myObject.variable; // doesn't work <br>
                    myObject[variable]; // looks for a property called 'otherProperty' and returns 77</code></li>
                    <li>Define an object like this: <br>
                    <code class="block">function Player(name, marker) { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;this.name = name; <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;this.marker = marker; <br>
                    }</code></li>
                    <li>And instantiate it like this: <br>
                        <code>const player = new Player('Steve', 'X');</code>
                    </li>
                    <li>You can add functions pretty much like any other language except you seem to have to write them like this, for instance in the previous Player object: <br>
                    <code class="block">this.sayName = function() { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);
                    }</code></li>
                    <li>Weirdly, you can call constructors without using the new keyword which does some bad stuff. So you can safeguard your constructor: <br>
                    <code class="block">if(!new.target) { <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;throw Error("Use 'new' operator!"); <br>
                    }</code></li>
                    <li>Course asks me to make a constructor for a book, I'm pretty confident.</li>
                    <li>Every object has a "prototype" which I think is the generic object blueprint that all instances of that object inherit from.</li>
                    <li>You can access an objects prototype through, for instance, <code>layer.prototype;</code> or <code>Object.getPrototypeOf(playerVariable);</code></li>
                    <li>You could see playerVariable.__proto__ or playerVariable.[[Prototype]] but these are deprecated.</li>
                    <li>Object prototypes inherit from a base Object prototype with some built-in functions available to all Objects.</li>
                    <li>Some built-in functions include <code>.valueOf()</code> which will get the value of an object, output varries by browser. Also <code>.hasOwnProperty('propertyName')</code> to check for the existance of a property.</li>
                    <li>JS is single-inheritance.</li>
                    <li>You use a line of code outside the object declaration to make an object inherit. It's with <code>Object.setPrototypeOf(AdvancedPlayer.prototype, Player.prototype)</code>. In this case AdvancedPlayer inherits from Player.</li>
                    <li>It's useful to check for prototype matches, too, with something like: <code>Array.prototype.isPrototypeOf(objectVariable);</code> in this case it checks if the "objectVariable" object is of type array.</li>
                    <li><mark>You need to set up this inheritance before instantiating any of the objects!</mark></li>
                    <li>You "can" do something like <code>AdvancedPlayer.prototype = Player.prototype;</code> but that overwrites its prototype, not adds it.</li>
                    <li>Note, a constructor function is just any old function. It's customary to capitalize its first letter and it's required to use the "new" keyword to instantiate it.</li>
                    <li>Thankfully it is common practice to define functions inside an object, not assign it later, for readability purposes.</li>
                    <li>I believe there's also function overloading. If a parent has a function and you assign a new function to a child objects function property it will be overwritten.</li>
                    <li>The inheriting object is used for variable storage. That's where the keyword <code>this</code> comes into play. It always references the object. There's a good <a href="https://javascript.info/prototype-inheritance#the-value-of-this">example here</a>. So if a function that's defined in the parent adds a property value to a child that value is stored in the child.</li>
                    <li><code>for..in</code> loops will go through all properties of an object. So <code>for(let prop in player) alert(prop);</code> would list all the properties in a Player object.</li>
                    <li>One article mentions "this" works just like it does in Java, C# or PHP. I don't feel the need to read further.</li>
                </ul>
            </section>
            <section>
                <h3>Factory Functions and the Module Pattern</h3>
                <ul>
                    <li><code>var</code> is "function scoped" which I think means it's open to anything within the function it's declared in, even if it's declared in a deeper scope</li>
                    <li><code>let, const</code> are block scoped, like a normal variable</li>
                    <li>This seems useful to remember: <br>
                    <code class="block">
                        function madeAdding(firstNumber) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const first = firstNumber; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return function resulting(secondNumber) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const second = secondNumber; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return first + second; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        } <br>
                        const add5 = makeAdding(5); <br>
                        console.log(add5(2)); // 7 is logged
                    </code>
                    The function returns a function so add5 is now the function that madeAdding() returned. Scope-wise, it also holds the value 5 somehow.</li>
                    <li>That '5' being maintained is called "lexical environment". When the function was declared it remembers the surrounding state.</li>
                    <li>Ahh, JS works a bit different. Blocks in JS don't create scopes. "let" and "const" functionally add block scope by being block scope.</li>
                        <li>An example use-case for this: <br>
                        <code class="block">
                            function makeSizer(size) { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return function () { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   document.body.style.fontSize = `${size}px`; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;}; <br>
                            } <br>
                            const size12 = makeSizer(12); <br>
                            const size16 = makeSizer(16); <br>
                            document.getElementById("size-12").onclick = size12; <br>
                            document.getElementById("size-16").onclick = size16;
                        </code>
                        This creates a "function factory". In this case it produces functions that change the pages font size that can be added to onclick events.</li>
                    <li>Apparently constructors, like classic, object-oriented class <mark>constructors, aren't great</mark>. They look like regular functions. <code>instanceof</code> ins't great in JS because the constructor could have been changed since the object was instantiated and this wouldn't reflect that.</li>
                    <li>Factory functions, like the above example, is more consistent but does have a performance hit.</li>
                    <li>Here's an example of a constructor refactored into a factory function: <br>
                    <code class="block">const User = function(name) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.discordName = '@' + name;<br>
                        }<br>
                        // refactor ...<br>
                        function createUser(name) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const discordName = '@' + name;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return { name, discordName };<br>
                        }
                    </code></li>
                    <li>Little aside: the above <code>{ name, discordName }</code> creates an object dynamically, kind of like <code>{ name: name, discordName: discordName }</code>, it's just that the internal variables of the object are named after the variables used to create it.</li>
                    <li>It lets you do neat things like <code>console.log({ name, age, color });</code> and it will output in a much more readable way that will list the variable name alongside their values.</li>
                    <li>Weirdly, you can deconstruct objects like this: <br>
                    <code class="block">
                        const obj = { a: 1, b: 2 }; <br>
                        const { a, b } = obj; <br>
                        <br>
                        const array = [1,2,3,4]; <br>
                        const [ zerothElement, firstElement ] = array;
                    </code>The first two lines create two variables, "a" and "b" that are the values of obj.a and obj.b respectively. The second two lines create two variables that are the first two elements of the array.</li>
                    <li>WTF, there's even weirder things in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring">this MDN article</a>.</li>
                    <li>The factory method lets us make private variables by taking advantage of that lexical environment. Having a variable in the factory counts as part of the context of the object creation but isn't an attribute accessable through, say, the dot operator. <br>
                        <code class="block">
                            function createUser(name) { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;let reputation = 0; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const getReputation = () => reputation; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const giveReputation = () => reputation++; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return { name, getReputation, giveReputation }; <br>
                            } <br>
                            const josh = createUser("josh"); <br>
                            josh.giveReputation(); <br>
                            console.log( { name: josh.name, reputation: josh.getReputation() } );
                        </code>
                    This basically creates a user object with methods but doesn't give access to the reputation variable since that's part of the lexical environment.</li>
                    <li>You can do this in a constructor, but <mark>inheritance doesn't have access to the context of the constructor</mark> so it's not a good combo.</li>
                    <li>We can extend factories like inheritance: <br>
                        <code class="block">
                        function createPlayer(name, level) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const { getReputation, giveReputation } = createUser(name); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;const increaseLevel = () => level++; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return { name, getReputation, giveReputation, increaseLevel }; <br>
                        }
                        </code>Apparently that's it. That can pull the old functions out, create new ones and return a new object with what was previously a User at its core.</li>
                    <li>There's an alternative to the return line: <br>
                        <code>return Object.assign({}, user, { increaseLevel });</code></li>
                        I'm not entirely sure how it works but I can look into it.
                    <li>There's another couple of useful things: the "module pattern" and IIFE's</li>
                    <li>IIFE stands for Immediately Invoked Function Expression and involves wrapping a function in brackets and then immediately calling it. This helps to encapsulate the variables and functions within. See this example:
                        <code class="block">
                            const calculator = (function () { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const add = (a, b) => a + b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const sub = (a, b) => a - b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const mul = (a, b) => a * b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;const div = (a, b) => a / b; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return { add, sub, mul, div }; <br>
                            })(); <br>
                            calculator.add(3,5); // 8 <br>
                            calculator.sub(6,2); // 4 <br>
                            calculator.mul(14,5534); // 77476 <br>
                        </code>
                        The generic function is wrapped in () and then there's a () right after it that invokes it.
                    </li>
                    <li>This method also helps encapsulate these functions by making it necessary to put <code>calculator.</code> in front of them to invoke them. This helps avoid global level functions from having naming conflicts.</li>
                    <li><mark>Avoid global variables!</mark></li>
                    <li>Heck, encapsulate your whole module in a self-acting function that returns to your module name.</li>
                </ul>
            </section>
            <section>
                <h3>Classes</h3>
                <ul>
                    <li>Interestingly, JS added classes but it's really only in name and syntax. They aren't like classes in other OO languages, it's just syntactic sugar for what I've already been doing.</li>
                    <li>So, for the syntactic sugar I can use <code>get, set</code> instead of <code>function</code> to basically do the same thing.</li>
                    <li>The neat thing: this makes it so that you can just use the dot operator and the get/set methods will be used automatically.</li>
                    <li>So if there's an object:
                        <code class="block">let user = { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;name: "John", <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;surname: "Smith",
                            &nbsp;&nbsp;&nbsp;&nbsp;get fullName() { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `${this.name} ${this.surname}`; <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;}, <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;set fullName(value) { <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[this.name, this.surname] = value.split(" ");<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                            }; <br></code>
                        Then you can call it with <code>user.fullName</code> or assign to it like <code>user.fullName = "Alice Cooper";</code>
                    </li>
                    <li>Class syntax is like this: <br>
                        <code class="block">class User { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;constructor(name) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;sayHi() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.name); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        } <br>
                        let user = new User("John"); <br>
                        user.sayHi();
                        </code></li>
                    <li>When the keyword <code>new</code> is used it implicitly, inside the constructor, creates an object called "this" before running all the other constructor instructions and then returns "this" at the end of it.</li>
                    <li><mark>You don't need to put a comma between class methods</mark>, unlike in object literals!</li>
                    <li><code>User</code> in the above code is still a function with the function code taken from the constructor. Class methods are stored in User.prototype.</li>
                    <li>We could (mostly) get the same function as creating a class doing it this way:
                        <code class="block">function User(name) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.name = name; <br>
                        } <br>
                        User.prototype.sayHi = function() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;alert(this.name); <br>
                        };</code>
                        Though <a href="https://javascript.info/class">this document</a> says (unlike TOP) that <mark>it's not just syntactic sugar!</mark>
                    </li>
                    <li>A function created by a class is labelled by a special, interal property <code>[[IsClassConstructor]]: true</code> that is checked for in a number of places.</li>
                    <li>It forces the usage of <code>new</code></li>
                    <li>Class methods are non-enumerable. This means if you for..in them you wont iterate over the class methods.</li>
                    <li>All code inside a class is in strict mode. (Makes it function a little closer to compiled languages I'm used to.)</li>
                    <li>Computed function names are weird.
                        <code class="block">class User { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;['say' + 'Hi']() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert("Hello"); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        }</code>
                    </li>
                    <li>Class fields seem just like fields. I can't really remember why this is unique in some way. They're just <br>
                    <code>name = "John";</code> and accesed through <code>user.name;</code>. </li>
                    <li>There's apparently an interesting issue called "losing this". Take this code: <br>
                    <code class="block">class Button { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;constructor(value) { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value; <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;click() { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(this.value); <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <br>
                        } <br>
                        let button = new Button("hello"); <br>
                        <mark>setTimeout(button.click, 1000); // undefined</mark></code></li>
                        The issue is the "click" function "losing this". You need to change it to:
                        <code class="block">click = () => { <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;alert(this.value); <br>
                        }</code>
                        I think this is related to the lexical environment concept.
                    <li>It's also apparently common parlance put an underscore in front of a public variable that you shouldn't mess with.</li>
                    <li>Interesting tip: if you have a depricated value in an object, say "age", and you replaced it with "birthday". You could create an age getter that calculates the age from birthday and returns that so the rest of the code doesn't have to be updated.</li>
                    <li>The next notes are from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">a few MDN articles</a>. TOP suggested not memorizing everything so these notes will be more sparse, probably ...</li>
                    <li>If you declare an object, it seems like it should have a function named <code>constructor</code></li>
                    <li>I don't know what a "static initialization block" is. Probably good to read more at some point.</li>
                    <li>You can actually declare methods or fields static. Use it instead of "let" or "function".</li>
                    <li>You seem to be able to define fields as private like <code>#height = 0;</code> (by adding the #). I think it makes referencing them an error?</li>
                    <li>You can do good ol <code>class Dog extends Animal { }</code></li>
                    <li><mark>If the child class has a constructor it needs to call <code>super()</code> in it!</mark></li>
                    <li>The right side of "extends" doesn't have to be an identifier. It just has to evaluate to a constructor.</li>
                </ul>
            </section>
        </section>
    </div>
</body>

</html>